--!strict
local BigInt = require("../../src/crypto/BigInt")
local StarkField = require("../../src/crypto/StarkField")

-- Stark prime P = 2^251 + 17 * 2^192 + 1
local STARK_PRIME_HEX = "0x800000000000011000000000000000000000000000000000000000000000001"

describe("StarkField - Constants", function()
	it("exposes the Stark prime P", function()
		expect(BigInt.toHex(StarkField.P)):toBe(STARK_PRIME_HEX)
	end)

	it("P has bit length 252", function()
		expect(BigInt.bitLength(StarkField.P)):toBe(252)
	end)
end)

describe("StarkField - Constructors", function()
	it("zero() creates zero element", function()
		local z = StarkField.zero()
		expect(StarkField.isZero(z)):toBe(true)
		expect(StarkField.toHex(z)):toBe("0x0")
	end)

	it("one() creates identity element", function()
		local one = StarkField.one()
		expect(StarkField.isZero(one)):toBe(false)
		expect(StarkField.toHex(one)):toBe("0x1")
	end)

	it("fromNumber creates field element", function()
		local n = StarkField.fromNumber(42)
		expect(StarkField.toHex(n)):toBe("0x2a")
	end)

	it("fromHex creates field element", function()
		local n = StarkField.fromHex("0xdeadbeef")
		expect(StarkField.toHex(n)):toBe("0xdeadbeef")
	end)

	it("fromHex reduces values >= P", function()
		-- P itself should reduce to 0
		local z = StarkField.fromHex(STARK_PRIME_HEX)
		expect(StarkField.isZero(z)):toBe(true)
	end)

	it("fromHex reduces P + 1 to 1", function()
		local p = BigInt.fromHex(STARK_PRIME_HEX)
		local pPlus1 = BigInt.add(p, BigInt.one())
		local felt = StarkField.fromHex(BigInt.toHex(pPlus1))
		expect(StarkField.eq(felt, StarkField.one())):toBe(true)
	end)
end)

describe("StarkField - Addition", function()
	it("adds small numbers", function()
		local a = StarkField.fromNumber(123456789)
		local b = StarkField.fromNumber(987654321)
		local c = StarkField.add(a, b)
		expect(StarkField.toHex(c)):toBe("0x423a35c6")
	end)

	it("add with zero is identity", function()
		local a = StarkField.fromNumber(42)
		local c = StarkField.add(a, StarkField.zero())
		expect(StarkField.eq(c, a)):toBe(true)
	end)

	it("add wraps around P", function()
		-- (P - 1) + 1 = 0 mod P
		local pMinus1 = StarkField.fromHex("0x800000000000011000000000000000000000000000000000000000000000000")
		local result = StarkField.add(pMinus1, StarkField.one())
		expect(StarkField.isZero(result)):toBe(true)
	end)

	it("add is commutative", function()
		local a = StarkField.fromHex("0xdeadbeef")
		local b = StarkField.fromHex("0xcafebabe")
		expect(StarkField.eq(StarkField.add(a, b), StarkField.add(b, a))):toBe(true)
	end)
end)

describe("StarkField - Subtraction", function()
	it("subtracts small numbers (a > b)", function()
		local a = StarkField.fromNumber(10)
		local b = StarkField.fromNumber(3)
		local c = StarkField.sub(a, b)
		expect(StarkField.toHex(c)):toBe("0x7")
	end)

	it("sub wraps around P (a < b)", function()
		-- 0 - 1 mod P = P - 1
		local result = StarkField.sub(StarkField.zero(), StarkField.one())
		local pMinus1 = BigInt.sub(StarkField.P, BigInt.one())
		expect(BigInt.eq(result, pMinus1)):toBe(true)
	end)

	it("sub self equals zero", function()
		local a = StarkField.fromHex("0xdeadbeef")
		expect(StarkField.isZero(StarkField.sub(a, a))):toBe(true)
	end)
end)

describe("StarkField - Negation", function()
	it("neg of zero is zero", function()
		expect(StarkField.isZero(StarkField.neg(StarkField.zero()))):toBe(true)
	end)

	it("a + neg(a) = 0", function()
		local a = StarkField.fromNumber(123456789)
		local negA = StarkField.neg(a)
		local sum = StarkField.add(a, negA)
		expect(StarkField.isZero(sum)):toBe(true)
	end)

	it("neg of 1 equals P - 1", function()
		local negOne = StarkField.neg(StarkField.one())
		local pMinus1 = BigInt.sub(StarkField.P, BigInt.one())
		expect(BigInt.eq(negOne, pMinus1)):toBe(true)
	end)
end)

describe("StarkField - Multiplication", function()
	it("multiplies small numbers", function()
		local a = StarkField.fromNumber(123456789)
		local b = StarkField.fromNumber(987654321)
		local c = StarkField.mul(a, b)
		-- 123456789 * 987654321 = 121932631112635269
		expect(StarkField.toHex(c)):toBe("0x1b13114fbff5385")
	end)

	it("mul by zero is zero", function()
		local a = StarkField.fromHex("0xdeadbeef")
		expect(StarkField.isZero(StarkField.mul(a, StarkField.zero()))):toBe(true)
	end)

	it("mul by one is identity", function()
		local a = StarkField.fromHex("0xdeadbeef")
		expect(StarkField.eq(StarkField.mul(a, StarkField.one()), a)):toBe(true)
	end)

	it("(P-1) * (P-1) = 1 mod P", function()
		-- (-1) * (-1) = 1
		local pMinus1 = StarkField.fromHex("0x800000000000011000000000000000000000000000000000000000000000000")
		local result = StarkField.mul(pMinus1, pMinus1)
		expect(StarkField.eq(result, StarkField.one())):toBe(true)
	end)

	it("mul is commutative", function()
		local a = StarkField.fromHex("0xdeadbeef12345678")
		local b = StarkField.fromHex("0xcafebabe87654321")
		expect(StarkField.eq(StarkField.mul(a, b), StarkField.mul(b, a))):toBe(true)
	end)

	it("mul is associative", function()
		local a = StarkField.fromNumber(7)
		local b = StarkField.fromNumber(11)
		local c = StarkField.fromNumber(13)
		local ab_c = StarkField.mul(StarkField.mul(a, b), c)
		local a_bc = StarkField.mul(a, StarkField.mul(b, c))
		expect(StarkField.eq(ab_c, a_bc)):toBe(true)
	end)

	it("mul distributes over add", function()
		local a = StarkField.fromNumber(5)
		local b = StarkField.fromNumber(7)
		local c = StarkField.fromNumber(11)
		-- a * (b + c) = a*b + a*c
		local lhs = StarkField.mul(a, StarkField.add(b, c))
		local rhs = StarkField.add(StarkField.mul(a, b), StarkField.mul(a, c))
		expect(StarkField.eq(lhs, rhs)):toBe(true)
	end)
end)

describe("StarkField - Square", function()
	it("square of small number", function()
		local a = StarkField.fromNumber(7)
		local sq = StarkField.square(a)
		expect(StarkField.eq(sq, StarkField.fromNumber(49))):toBe(true)
	end)

	it("square equals mul(a, a)", function()
		local a = StarkField.fromHex("0xdeadbeef12345678cafebabe")
		expect(StarkField.eq(StarkField.square(a), StarkField.mul(a, a))):toBe(true)
	end)

	it("square of zero is zero", function()
		expect(StarkField.isZero(StarkField.square(StarkField.zero()))):toBe(true)
	end)

	it("square of one is one", function()
		expect(StarkField.eq(StarkField.square(StarkField.one()), StarkField.one())):toBe(true)
	end)
end)

describe("StarkField - Inversion", function()
	it("inv of 1 is 1", function()
		local inv = StarkField.inv(StarkField.one())
		expect(StarkField.eq(inv, StarkField.one())):toBe(true)
	end)

	it("a * inv(a) = 1", function()
		local a = StarkField.fromNumber(123456789)
		local inv = StarkField.inv(a)
		local product = StarkField.mul(a, inv)
		expect(StarkField.eq(product, StarkField.one())):toBe(true)
	end)

	it("inv of large value", function()
		local a = StarkField.fromHex("0xdeadbeef")
		local inv = StarkField.inv(a)
		local product = StarkField.mul(a, inv)
		expect(StarkField.eq(product, StarkField.one())):toBe(true)
	end)

	it("inv of P-1 is P-1 (since (-1)^(-1) = -1)", function()
		local pMinus1 = StarkField.fromHex("0x800000000000011000000000000000000000000000000000000000000000000")
		local inv = StarkField.inv(pMinus1)
		expect(StarkField.eq(inv, pMinus1)):toBe(true)
	end)

	it("inv of zero throws", function()
		expect(function()
			StarkField.inv(StarkField.zero())
		end):toThrow()
	end)

	it("double inversion returns original", function()
		local a = StarkField.fromHex("0xcafebabe87654321")
		local inv2 = StarkField.inv(StarkField.inv(a))
		expect(StarkField.eq(inv2, a)):toBe(true)
	end)
end)

describe("StarkField - Square Root", function()
	it("sqrt of zero is zero", function()
		local root = StarkField.sqrt(StarkField.zero())
		expect(root ~= nil):toBe(true)
		expect(StarkField.isZero(root :: buffer)):toBe(true)
	end)

	it("sqrt of one is one", function()
		local root = StarkField.sqrt(StarkField.one())
		expect(root ~= nil):toBe(true)
		expect(StarkField.eq(root :: buffer, StarkField.one())):toBe(true)
	end)

	it("sqrt of 4 squares back to 4", function()
		local four = StarkField.fromNumber(4)
		local root = StarkField.sqrt(four)
		expect(root ~= nil):toBe(true)
		local squared = StarkField.square(root :: buffer)
		expect(StarkField.eq(squared, four)):toBe(true)
	end)

	it("sqrt of perfect square (49)", function()
		local n = StarkField.fromNumber(49)
		local root = StarkField.sqrt(n)
		expect(root ~= nil):toBe(true)
		local squared = StarkField.square(root :: buffer)
		expect(StarkField.eq(squared, n)):toBe(true)
	end)

	it("sqrt of a^2 squares back correctly for large value", function()
		local a = StarkField.fromHex("0xdeadbeef12345678")
		local aSq = StarkField.square(a)
		local root = StarkField.sqrt(aSq)
		expect(root ~= nil):toBe(true)
		-- root should be either a or P - a
		local rootSq = StarkField.square(root :: buffer)
		expect(StarkField.eq(rootSq, aSq)):toBe(true)
	end)

	it("sqrt returns nil for non-residue", function()
		-- 3 is a known quadratic non-residue mod P
		local three = StarkField.fromNumber(3)
		local root = StarkField.sqrt(three)
		expect(root == nil):toBe(true)
	end)
end)

describe("StarkField - Conversions", function()
	it("toHex round-trips", function()
		local hex = "0xdeadbeef12345678cafebabe"
		local felt = StarkField.fromHex(hex)
		expect(StarkField.toHex(felt)):toBe(hex)
	end)

	it("toBigInt creates independent copy", function()
		local felt = StarkField.fromNumber(42)
		local bi = StarkField.toBigInt(felt)
		expect(BigInt.eq(felt, bi)):toBe(true)
	end)

	it("eq returns true for equal values", function()
		local a = StarkField.fromNumber(42)
		local b = StarkField.fromNumber(42)
		expect(StarkField.eq(a, b)):toBe(true)
	end)

	it("eq returns false for different values", function()
		local a = StarkField.fromNumber(42)
		local b = StarkField.fromNumber(43)
		expect(StarkField.eq(a, b)):toBe(false)
	end)
end)

describe("StarkField - Field Properties", function()
	it("additive identity: a + 0 = a", function()
		local a = StarkField.fromHex("0xdeadbeef")
		expect(StarkField.eq(StarkField.add(a, StarkField.zero()), a)):toBe(true)
	end)

	it("multiplicative identity: a * 1 = a", function()
		local a = StarkField.fromHex("0xdeadbeef")
		expect(StarkField.eq(StarkField.mul(a, StarkField.one()), a)):toBe(true)
	end)

	it("additive inverse: a + (-a) = 0", function()
		local a = StarkField.fromHex("0xdeadbeef12345678")
		expect(StarkField.isZero(StarkField.add(a, StarkField.neg(a)))):toBe(true)
	end)

	it("multiplicative inverse: a * a^(-1) = 1", function()
		local a = StarkField.fromHex("0xdeadbeef12345678")
		expect(StarkField.eq(StarkField.mul(a, StarkField.inv(a)), StarkField.one())):toBe(true)
	end)

	it("subtraction is add + neg: a - b = a + (-b)", function()
		local a = StarkField.fromNumber(5)
		local b = StarkField.fromNumber(8)
		local sub = StarkField.sub(a, b)
		local addNeg = StarkField.add(a, StarkField.neg(b))
		expect(StarkField.eq(sub, addNeg)):toBe(true)
	end)

	it("division via mul + inv: a/b = a * inv(b)", function()
		local a = StarkField.fromNumber(42)
		local b = StarkField.fromNumber(7)
		local quotient = StarkField.mul(a, StarkField.inv(b))
		expect(StarkField.eq(quotient, StarkField.fromNumber(6))):toBe(true)
	end)
end)

describe("StarkField - Edge Cases", function()
	it("max field value P-1", function()
		local pMinus1Hex = "0x800000000000011000000000000000000000000000000000000000000000000"
		local pMinus1 = StarkField.fromHex(pMinus1Hex)
		expect(StarkField.isZero(pMinus1)):toBe(false)
		expect(StarkField.toHex(pMinus1)):toBe(pMinus1Hex)
	end)

	it("P reduces to zero", function()
		expect(StarkField.isZero(StarkField.fromHex(STARK_PRIME_HEX))):toBe(true)
	end)

	it("2P reduces to zero", function()
		local twoP = BigInt.add(StarkField.P, StarkField.P)
		local felt = StarkField.fromHex(BigInt.toHex(twoP))
		expect(StarkField.isZero(felt)):toBe(true)
	end)

	it("operations chain correctly", function()
		-- (a + b) * c - a*c should equal b*c
		local a = StarkField.fromNumber(17)
		local b = StarkField.fromNumber(23)
		local c = StarkField.fromNumber(31)
		local lhs = StarkField.sub(StarkField.mul(StarkField.add(a, b), c), StarkField.mul(a, c))
		local rhs = StarkField.mul(b, c)
		expect(StarkField.eq(lhs, rhs)):toBe(true)
	end)

	it("large value arithmetic", function()
		-- Test with values close to P
		local a = StarkField.fromHex("0x7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff")
		local b = StarkField.fromHex("0x7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff")
		local sum = StarkField.add(a, b)
		-- sum should be < P (properly reduced)
		expect(BigInt.cmp(sum, StarkField.P) < 0):toBe(true)
	end)
end)
