--!strict
local BigInt = require("../../src/crypto/BigInt")

-- Stark prime P = 2^251 + 17 * 2^192 + 1
local STARK_PRIME_HEX = "0x800000000000011000000000000000000000000000000000000000000000001"
-- Curve order N
local CURVE_ORDER_HEX = "0x800000000000010ffffffffffffffffb781126dcae7b2321e66a241adc64d2f"

describe("BigInt - Constructors", function()
	it("creates zero", function()
		local z = BigInt.zero()
		expect(BigInt.isZero(z)):toBe(true)
		expect(BigInt.toHex(z)):toBe("0x0")
	end)

	it("creates one", function()
		local one = BigInt.one()
		expect(BigInt.isZero(one)):toBe(false)
		expect(BigInt.toHex(one)):toBe("0x1")
	end)

	it("creates from small number", function()
		local n = BigInt.fromNumber(42)
		expect(BigInt.toHex(n)):toBe("0x2a")
		expect(BigInt.toNumber(n)):toBe(42)
	end)

	it("creates from large number", function()
		-- 2^24 = 16777216 (crosses limb boundary)
		local n = BigInt.fromNumber(16777216)
		expect(BigInt.toHex(n)):toBe("0x1000000")
		expect(BigInt.toNumber(n)):toBe(16777216)
	end)

	it("creates from zero number", function()
		local n = BigInt.fromNumber(0)
		expect(BigInt.isZero(n)):toBe(true)
	end)

	it("creates from hex string", function()
		local n = BigInt.fromHex("0xff")
		expect(BigInt.toNumber(n)):toBe(255)
	end)

	it("creates from hex without prefix", function()
		local n = BigInt.fromHex("ff")
		expect(BigInt.toNumber(n)):toBe(255)
	end)

	it("creates from large hex (Stark prime)", function()
		local p = BigInt.fromHex(STARK_PRIME_HEX)
		expect(BigInt.toHex(p)):toBe(STARK_PRIME_HEX)
	end)

	it("creates from hex with leading zeros", function()
		local n = BigInt.fromHex("0x00002a")
		expect(BigInt.toHex(n)):toBe("0x2a")
	end)

	it("creates from bytes", function()
		-- [0x01, 0x00] = 256 in big-endian
		local buf = buffer.create(2)
		buffer.writeu8(buf, 0, 1)
		buffer.writeu8(buf, 1, 0)
		local n = BigInt.fromBytes(buf)
		expect(BigInt.toNumber(n)):toBe(256)
	end)

	it("creates from single byte", function()
		local buf = buffer.create(1)
		buffer.writeu8(buf, 0, 42)
		local n = BigInt.fromBytes(buf)
		expect(BigInt.toNumber(n)):toBe(42)
	end)

	it("round-trips hex for Stark prime", function()
		local p = BigInt.fromHex(STARK_PRIME_HEX)
		expect(BigInt.toHex(p)):toBe(STARK_PRIME_HEX)
	end)

	it("round-trips hex for curve order", function()
		local n = BigInt.fromHex(CURVE_ORDER_HEX)
		expect(BigInt.toHex(n)):toBe(CURVE_ORDER_HEX)
	end)
end)

describe("BigInt - Conversions", function()
	it("toNumber for small values", function()
		expect(BigInt.toNumber(BigInt.fromNumber(0))):toBe(0)
		expect(BigInt.toNumber(BigInt.fromNumber(1))):toBe(1)
		expect(BigInt.toNumber(BigInt.fromNumber(12345))):toBe(12345)
	end)

	it("toBytes round-trip", function()
		local n = BigInt.fromHex("0xdeadbeef")
		local bytes = BigInt.toBytes(n)
		local m = BigInt.fromBytes(bytes)
		expect(BigInt.eq(n, m)):toBe(true)
	end)

	it("toBytes for zero", function()
		local bytes = BigInt.toBytes(BigInt.zero())
		expect(buffer.len(bytes)):toBe(1)
		expect(buffer.readu8(bytes, 0)):toBe(0)
	end)

	it("toBytes for large value round-trip", function()
		local p = BigInt.fromHex(STARK_PRIME_HEX)
		local bytes = BigInt.toBytes(p)
		local p2 = BigInt.fromBytes(bytes)
		expect(BigInt.eq(p, p2)):toBe(true)
	end)
end)

describe("BigInt - Comparison", function()
	it("eq for equal values", function()
		local a = BigInt.fromNumber(42)
		local b = BigInt.fromNumber(42)
		expect(BigInt.eq(a, b)):toBe(true)
	end)

	it("eq for different values", function()
		local a = BigInt.fromNumber(42)
		local b = BigInt.fromNumber(43)
		expect(BigInt.eq(a, b)):toBe(false)
	end)

	it("lt", function()
		local a = BigInt.fromNumber(5)
		local b = BigInt.fromNumber(10)
		expect(BigInt.lt(a, b)):toBe(true)
		expect(BigInt.lt(b, a)):toBe(false)
		expect(BigInt.lt(a, a)):toBe(false)
	end)

	it("lte", function()
		local a = BigInt.fromNumber(5)
		local b = BigInt.fromNumber(10)
		expect(BigInt.lte(a, b)):toBe(true)
		expect(BigInt.lte(a, a)):toBe(true)
		expect(BigInt.lte(b, a)):toBe(false)
	end)

	it("cmp", function()
		local a = BigInt.fromNumber(5)
		local b = BigInt.fromNumber(10)
		expect(BigInt.cmp(a, b)):toBe(-1)
		expect(BigInt.cmp(b, a)):toBe(1)
		expect(BigInt.cmp(a, a)):toBe(0)
	end)

	it("cmp for large values", function()
		local p = BigInt.fromHex(STARK_PRIME_HEX)
		local n = BigInt.fromHex(CURVE_ORDER_HEX)
		-- P > N (prime is larger than curve order)
		expect(BigInt.cmp(p, n)):toBe(1)
	end)

	it("isZero", function()
		expect(BigInt.isZero(BigInt.zero())):toBe(true)
		expect(BigInt.isZero(BigInt.one())):toBe(false)
	end)
end)

describe("BigInt - Addition", function()
	it("adds small numbers", function()
		local a = BigInt.fromNumber(3)
		local b = BigInt.fromNumber(4)
		local c = BigInt.add(a, b)
		expect(BigInt.toNumber(c)):toBe(7)
	end)

	it("adds with carry across limb boundary", function()
		-- (2^24 - 1) + 1 = 2^24
		local a = BigInt.fromNumber(16777215) -- 0xFFFFFF
		local b = BigInt.fromNumber(1)
		local c = BigInt.add(a, b)
		expect(BigInt.toNumber(c)):toBe(16777216)
	end)

	it("adds zero", function()
		local a = BigInt.fromNumber(42)
		local c = BigInt.add(a, BigInt.zero())
		expect(BigInt.toNumber(c)):toBe(42)
	end)

	it("adds large values", function()
		local a = BigInt.fromHex("0xffffffffffffffffffff") -- 80 bits
		local b = BigInt.fromHex("0x1")
		local c = BigInt.add(a, b)
		expect(BigInt.toHex(c)):toBe("0x100000000000000000000")
	end)
end)

describe("BigInt - Subtraction", function()
	it("subtracts small numbers", function()
		local a = BigInt.fromNumber(10)
		local b = BigInt.fromNumber(3)
		local c = BigInt.sub(a, b)
		expect(BigInt.toNumber(c)):toBe(7)
	end)

	it("subtracts with borrow", function()
		local a = BigInt.fromNumber(16777216) -- 2^24
		local b = BigInt.fromNumber(1)
		local c = BigInt.sub(a, b)
		expect(BigInt.toNumber(c)):toBe(16777215)
	end)

	it("subtracts equal values gives zero", function()
		local a = BigInt.fromNumber(42)
		local c = BigInt.sub(a, a)
		expect(BigInt.isZero(c)):toBe(true)
	end)

	it("subtracts zero", function()
		local a = BigInt.fromNumber(42)
		local c = BigInt.sub(a, BigInt.zero())
		expect(BigInt.toNumber(c)):toBe(42)
	end)
end)

describe("BigInt - Multiplication", function()
	it("multiplies small numbers", function()
		local a = BigInt.fromNumber(6)
		local b = BigInt.fromNumber(7)
		local c = BigInt.mul(a, b)
		expect(BigInt.toNumber(c)):toBe(42)
	end)

	it("multiplies by zero", function()
		local a = BigInt.fromNumber(42)
		local c = BigInt.mul(a, BigInt.zero())
		expect(BigInt.isZero(c)):toBe(true)
	end)

	it("multiplies by one", function()
		local a = BigInt.fromNumber(42)
		local c = BigInt.mul(a, BigInt.one())
		expect(BigInt.toNumber(c)):toBe(42)
	end)

	it("multiplies across limb boundary", function()
		-- 2^12 * 2^12 = 2^24 (crosses into next limb)
		local a = BigInt.fromNumber(4096)
		local b = BigInt.fromNumber(4096)
		local c = BigInt.mul(a, b)
		expect(BigInt.toNumber(c)):toBe(16777216)
	end)

	it("multiplies larger numbers", function()
		-- 0xff * 0xff = 0xfe01
		local a = BigInt.fromNumber(255)
		local b = BigInt.fromNumber(255)
		local c = BigInt.mul(a, b)
		expect(BigInt.toNumber(c)):toBe(65025)
	end)
end)

describe("BigInt - Division", function()
	it("divides evenly", function()
		local a = BigInt.fromNumber(42)
		local b = BigInt.fromNumber(7)
		local q = BigInt.div(a, b)
		expect(BigInt.toNumber(q)):toBe(6)
	end)

	it("divides with remainder", function()
		local a = BigInt.fromNumber(43)
		local b = BigInt.fromNumber(7)
		local q, r = BigInt.divmod(a, b)
		expect(BigInt.toNumber(q)):toBe(6)
		expect(BigInt.toNumber(r)):toBe(1)
	end)

	it("mod", function()
		local a = BigInt.fromNumber(43)
		local b = BigInt.fromNumber(7)
		expect(BigInt.toNumber(BigInt.mod(a, b))):toBe(1)
	end)

	it("divides smaller by larger", function()
		local a = BigInt.fromNumber(3)
		local b = BigInt.fromNumber(7)
		local q, r = BigInt.divmod(a, b)
		expect(BigInt.isZero(q)):toBe(true)
		expect(BigInt.toNumber(r)):toBe(3)
	end)

	it("divides equal values", function()
		local a = BigInt.fromNumber(42)
		local q, r = BigInt.divmod(a, a)
		expect(BigInt.toNumber(q)):toBe(1)
		expect(BigInt.isZero(r)):toBe(true)
	end)

	it("division by zero throws", function()
		expect(function()
			BigInt.divmod(BigInt.one(), BigInt.zero())
		end):toThrow()
	end)

	it("divides large numbers correctly", function()
		-- 100 / 10 = 10 (in hex: 0x64 / 0xa = 0xa)
		local a = BigInt.fromNumber(100)
		local b = BigInt.fromNumber(10)
		local q = BigInt.div(a, b)
		expect(BigInt.toNumber(q)):toBe(10)
	end)

	it("divmod large hex values", function()
		-- (P - 1) mod 2 should be 0 (P is odd, P-1 is even)
		local p = BigInt.fromHex(STARK_PRIME_HEX)
		local pMinus1 = BigInt.sub(p, BigInt.one())
		local two = BigInt.fromNumber(2)
		local _, r = BigInt.divmod(pMinus1, two)
		expect(BigInt.isZero(r)):toBe(true)
	end)
end)

describe("BigInt - Bitwise Operations", function()
	it("bitLength of zero is 0", function()
		expect(BigInt.bitLength(BigInt.zero())):toBe(0)
	end)

	it("bitLength of one is 1", function()
		expect(BigInt.bitLength(BigInt.one())):toBe(1)
	end)

	it("bitLength of 255 is 8", function()
		expect(BigInt.bitLength(BigInt.fromNumber(255))):toBe(8)
	end)

	it("bitLength of 256 is 9", function()
		expect(BigInt.bitLength(BigInt.fromNumber(256))):toBe(9)
	end)

	it("bitLength of Stark prime is 252", function()
		local p = BigInt.fromHex(STARK_PRIME_HEX)
		expect(BigInt.bitLength(p)):toBe(252)
	end)

	it("getBit", function()
		local n = BigInt.fromNumber(5) -- binary: 101
		expect(BigInt.getBit(n, 0)):toBe(1)
		expect(BigInt.getBit(n, 1)):toBe(0)
		expect(BigInt.getBit(n, 2)):toBe(1)
		expect(BigInt.getBit(n, 3)):toBe(0)
	end)

	it("shl by 1", function()
		local a = BigInt.fromNumber(5)
		local b = BigInt.shl(a, 1)
		expect(BigInt.toNumber(b)):toBe(10)
	end)

	it("shl by 24 (full limb)", function()
		local a = BigInt.fromNumber(1)
		local b = BigInt.shl(a, 24)
		expect(BigInt.toNumber(b)):toBe(16777216)
	end)

	it("shl by 0 returns clone", function()
		local a = BigInt.fromNumber(42)
		local b = BigInt.shl(a, 0)
		expect(BigInt.eq(a, b)):toBe(true)
	end)

	it("shr by 1", function()
		local a = BigInt.fromNumber(10)
		local b = BigInt.shr(a, 1)
		expect(BigInt.toNumber(b)):toBe(5)
	end)

	it("shr by 24 (full limb)", function()
		local a = BigInt.fromNumber(16777216)
		local b = BigInt.shr(a, 24)
		expect(BigInt.toNumber(b)):toBe(1)
	end)

	it("shr rounds down", function()
		local a = BigInt.fromNumber(5)
		local b = BigInt.shr(a, 1) -- 5 >> 1 = 2
		expect(BigInt.toNumber(b)):toBe(2)
	end)

	it("band", function()
		local a = BigInt.fromNumber(0xFF)
		local b = BigInt.fromNumber(0x0F)
		local c = BigInt.band(a, b)
		expect(BigInt.toNumber(c)):toBe(0x0F)
	end)

	it("bor", function()
		local a = BigInt.fromNumber(0xF0)
		local b = BigInt.fromNumber(0x0F)
		local c = BigInt.bor(a, b)
		expect(BigInt.toNumber(c)):toBe(0xFF)
	end)

	it("shl and shr round-trip", function()
		local a = BigInt.fromHex("0xdeadbeef12345678")
		local shifted = BigInt.shl(a, 37)
		local back = BigInt.shr(shifted, 37)
		expect(BigInt.eq(a, back)):toBe(true)
	end)
end)

describe("BigInt - Modular Arithmetic", function()
	it("addmod", function()
		local a = BigInt.fromNumber(5)
		local b = BigInt.fromNumber(8)
		local m = BigInt.fromNumber(7)
		-- (5 + 8) mod 7 = 13 mod 7 = 6
		local c = BigInt.addmod(a, b, m)
		expect(BigInt.toNumber(c)):toBe(6)
	end)

	it("addmod no overflow", function()
		local a = BigInt.fromNumber(2)
		local b = BigInt.fromNumber(3)
		local m = BigInt.fromNumber(7)
		-- (2 + 3) mod 7 = 5
		expect(BigInt.toNumber(BigInt.addmod(a, b, m))):toBe(5)
	end)

	it("submod a >= b", function()
		local a = BigInt.fromNumber(5)
		local b = BigInt.fromNumber(3)
		local m = BigInt.fromNumber(7)
		-- (5 - 3) mod 7 = 2
		expect(BigInt.toNumber(BigInt.submod(a, b, m))):toBe(2)
	end)

	it("submod a < b (wraps)", function()
		local a = BigInt.fromNumber(3)
		local b = BigInt.fromNumber(5)
		local m = BigInt.fromNumber(7)
		-- (3 - 5) mod 7 = -2 mod 7 = 5
		expect(BigInt.toNumber(BigInt.submod(a, b, m))):toBe(5)
	end)

	it("submod equal values gives zero", function()
		local a = BigInt.fromNumber(5)
		local m = BigInt.fromNumber(7)
		expect(BigInt.isZero(BigInt.submod(a, a, m))):toBe(true)
	end)

	it("mulmod small", function()
		local a = BigInt.fromNumber(5)
		local b = BigInt.fromNumber(6)
		local m = BigInt.fromNumber(7)
		-- (5 * 6) mod 7 = 30 mod 7 = 2
		expect(BigInt.toNumber(BigInt.mulmod(a, b, m))):toBe(2)
	end)

	it("mulmod large values (Stark prime)", function()
		local p = BigInt.fromHex(STARK_PRIME_HEX)
		-- (P - 1) * (P - 1) mod P should equal 1
		-- Because (P-1) = -1 mod P, so (-1)*(-1) = 1 mod P
		local pMinus1 = BigInt.sub(p, BigInt.one())
		local result = BigInt.mulmod(pMinus1, pMinus1, p)
		expect(BigInt.eq(result, BigInt.one())):toBe(true)
	end)

	it("mulmod by one is identity", function()
		local a = BigInt.fromNumber(42)
		local m = BigInt.fromNumber(100)
		local result = BigInt.mulmod(a, BigInt.one(), m)
		expect(BigInt.toNumber(result)):toBe(42)
	end)

	it("mulmod by zero is zero", function()
		local a = BigInt.fromNumber(42)
		local m = BigInt.fromNumber(100)
		local result = BigInt.mulmod(a, BigInt.zero(), m)
		expect(BigInt.isZero(result)):toBe(true)
	end)

	it("powmod small", function()
		-- 2^10 mod 1000 = 1024 mod 1000 = 24
		local base = BigInt.fromNumber(2)
		local exp = BigInt.fromNumber(10)
		local m = BigInt.fromNumber(1000)
		expect(BigInt.toNumber(BigInt.powmod(base, exp, m))):toBe(24)
	end)

	it("powmod exponent zero returns one", function()
		local base = BigInt.fromNumber(42)
		local m = BigInt.fromNumber(100)
		local result = BigInt.powmod(base, BigInt.zero(), m)
		expect(BigInt.eq(result, BigInt.one())):toBe(true)
	end)

	it("powmod Fermat's little theorem", function()
		-- For prime p and a not divisible by p: a^(p-1) = 1 mod p
		-- Use a small prime for speed: p = 97, a = 5
		local a = BigInt.fromNumber(5)
		local p = BigInt.fromNumber(97)
		local pMinus1 = BigInt.fromNumber(96)
		local result = BigInt.powmod(a, pMinus1, p)
		expect(BigInt.eq(result, BigInt.one())):toBe(true)
	end)

	it("powmod with Stark prime (Fermat)", function()
		-- a^(P-1) mod P = 1 for any a in [1, P-1]
		local p = BigInt.fromHex(STARK_PRIME_HEX)
		local a = BigInt.fromNumber(7)
		local pMinus1 = BigInt.sub(p, BigInt.one())
		local result = BigInt.powmod(a, pMinus1, p)
		expect(BigInt.eq(result, BigInt.one())):toBe(true)
	end)

	it("invmod small", function()
		-- 3^(-1) mod 7 = 5 (since 3*5 = 15 = 2*7 + 1)
		local a = BigInt.fromNumber(3)
		local m = BigInt.fromNumber(7)
		local inv = BigInt.invmod(a, m)
		expect(BigInt.toNumber(inv)):toBe(5)
	end)

	it("invmod verification (a * inv(a) = 1 mod m)", function()
		local a = BigInt.fromNumber(17)
		local m = BigInt.fromNumber(97) -- prime
		local inv = BigInt.invmod(a, m)
		local product = BigInt.mulmod(a, inv, m)
		expect(BigInt.eq(product, BigInt.one())):toBe(true)
	end)

	it("invmod with Stark prime", function()
		local p = BigInt.fromHex(STARK_PRIME_HEX)
		local a = BigInt.fromHex("0xdeadbeef")
		local inv = BigInt.invmod(a, p)
		local product = BigInt.mulmod(a, inv, p)
		expect(BigInt.eq(product, BigInt.one())):toBe(true)
	end)

	it("invmod of one is one", function()
		local m = BigInt.fromNumber(97)
		local inv = BigInt.invmod(BigInt.one(), m)
		expect(BigInt.eq(inv, BigInt.one())):toBe(true)
	end)

	it("invmod of zero throws", function()
		expect(function()
			BigInt.invmod(BigInt.zero(), BigInt.fromNumber(7))
		end):toThrow()
	end)
end)

describe("BigInt - Barrett Reduction", function()
	it("creates Barrett context", function()
		local m = BigInt.fromNumber(97)
		local ctx = BigInt.createBarrettCtx(m)
		expect(ctx.k):toBe(7) -- bitLength of 97
		expect(BigInt.eq(ctx.m, m)):toBe(true)
	end)

	it("mulmodB matches mulmod for small values", function()
		local m = BigInt.fromNumber(97)
		local ctx = BigInt.createBarrettCtx(m)
		local a = BigInt.fromNumber(42)
		local b = BigInt.fromNumber(58)
		local expected = BigInt.mulmod(a, b, m)
		local result = BigInt.mulmodB(a, b, ctx)
		expect(BigInt.eq(result, expected)):toBe(true)
	end)

	it("mulmodB with Stark prime", function()
		local p = BigInt.fromHex(STARK_PRIME_HEX)
		local ctx = BigInt.createBarrettCtx(p)
		local a = BigInt.fromHex("0xdeadbeef12345678")
		local b = BigInt.fromHex("0xcafebabe87654321")
		local expected = BigInt.mulmod(a, b, p)
		local result = BigInt.mulmodB(a, b, ctx)
		expect(BigInt.eq(result, expected)):toBe(true)
	end)

	it("mulmodB (P-1)*(P-1) mod P = 1", function()
		local p = BigInt.fromHex(STARK_PRIME_HEX)
		local ctx = BigInt.createBarrettCtx(p)
		local pMinus1 = BigInt.sub(p, BigInt.one())
		local result = BigInt.mulmodB(pMinus1, pMinus1, ctx)
		expect(BigInt.eq(result, BigInt.one())):toBe(true)
	end)
end)

describe("BigInt - Edge Cases", function()
	it("max field value (P - 1) round-trips", function()
		local p = BigInt.fromHex(STARK_PRIME_HEX)
		local pMinus1 = BigInt.sub(p, BigInt.one())
		local hex = BigInt.toHex(pMinus1)
		local rebuilt = BigInt.fromHex(hex)
		expect(BigInt.eq(pMinus1, rebuilt)):toBe(true)
	end)

	it("clone creates independent copy", function()
		local a = BigInt.fromNumber(42)
		local b = BigInt.clone(a)
		expect(BigInt.eq(a, b)):toBe(true)
		-- They should be separate buffers
		local c = BigInt.add(b, BigInt.one())
		expect(BigInt.toNumber(a)):toBe(42) -- original unchanged
		expect(BigInt.toNumber(c)):toBe(43)
	end)

	it("operations near limb boundaries", function()
		-- Test at each limb boundary: 2^24, 2^48, 2^72
		local v24 = BigInt.shl(BigInt.one(), 24)
		expect(BigInt.toHex(v24)):toBe("0x1000000")

		local v48 = BigInt.shl(BigInt.one(), 48)
		expect(BigInt.toHex(v48)):toBe("0x1000000000000")

		local v72 = BigInt.shl(BigInt.one(), 72)
		expect(BigInt.toHex(v72)):toBe("0x1000000000000000000")
	end)

	it("cross-reference: 2^251 in hex", function()
		local v = BigInt.shl(BigInt.one(), 251)
		expect(BigInt.toHex(v)):toBe("0x800000000000000000000000000000000000000000000000000000000000000")
	end)

	it("add then sub round-trip", function()
		local a = BigInt.fromHex("0xdeadbeef12345678cafebabe")
		local b = BigInt.fromHex("0x1234567890abcdef")
		local sum = BigInt.add(a, b)
		local diff = BigInt.sub(sum, b)
		expect(BigInt.eq(diff, a)):toBe(true)
	end)

	it("mul then divmod round-trip", function()
		local a = BigInt.fromNumber(12345)
		local b = BigInt.fromNumber(67890)
		local product = BigInt.mul(a, b)
		local q, r = BigInt.divmod(product, b)
		expect(BigInt.eq(q, a)):toBe(true)
		expect(BigInt.isZero(r)):toBe(true)
	end)

	it("shl large shift (240 bits)", function()
		local a = BigInt.one()
		local b = BigInt.shl(a, 240)
		expect(BigInt.bitLength(b)):toBe(241)
		local c = BigInt.shr(b, 240)
		expect(BigInt.eq(c, a)):toBe(true)
	end)
end)
