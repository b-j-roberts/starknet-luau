--!strict
local BigInt = require("../../src/crypto/BigInt")
local StarkField = require("../../src/crypto/StarkField")
local StarkCurve = require("../../src/crypto/StarkCurve")

-- Known constants
local GX_HEX = "0x1ef15c18599971b7beced415a40f0c7deacfd9b0d1819e03d723d8bc943cfca"
local GY_HEX = "0x5668060aa49730b7be4801df46ec62de53ecd11abe43a32873000c36e8dc1f"
local BETA_HEX = "0x6f21413efbe40de150e596d72f7a8c5609ad26c15c915c1f4cdfcb99cee9e89"
local N_HEX = "0x800000000000010ffffffffffffffffb781126dcae7b2321e66a241adc64d2f"

describe("StarkCurve - Constants", function()
	it("ALPHA is 1", function()
		expect(StarkField.eq(StarkCurve.ALPHA, StarkField.one())):toBe(true)
	end)

	it("BETA has correct value", function()
		expect(StarkField.toHex(StarkCurve.BETA)):toBe(BETA_HEX)
	end)

	it("generator G has correct x coordinate", function()
		expect(StarkField.toHex(StarkCurve.G.x)):toBe(GX_HEX)
	end)

	it("generator G has correct y coordinate", function()
		expect(StarkField.toHex(StarkCurve.G.y)):toBe(GY_HEX)
	end)

	it("curve order N has correct value", function()
		expect(BigInt.toHex(StarkCurve.N)):toBe(N_HEX)
	end)

	it("generator G is on the curve", function()
		expect(StarkCurve.isOnCurve(StarkCurve.G)):toBe(true)
	end)
end)

describe("StarkCurve - isOnCurve", function()
	it("G is on the curve", function()
		expect(StarkCurve.isOnCurve(StarkCurve.G)):toBe(true)
	end)

	it("random point is not on curve", function()
		local fake = { x = StarkField.fromNumber(1), y = StarkField.fromNumber(2) }
		expect(StarkCurve.isOnCurve(fake)):toBe(false)
	end)

	it("negation of G is on curve", function()
		local negG = StarkCurve.affineNeg(StarkCurve.G)
		expect(StarkCurve.isOnCurve(negG)):toBe(true)
	end)

	it("point (0, sqrt(beta)) is on curve if sqrt exists", function()
		-- y² = 0 + 0 + β = β, so y = sqrt(β)
		local sqrtBeta = StarkField.sqrt(StarkCurve.BETA)
		if sqrtBeta then
			local p = { x = StarkField.zero(), y = sqrtBeta }
			expect(StarkCurve.isOnCurve(p)):toBe(true)
		end
	end)
end)

describe("StarkCurve - Coordinate Conversion", function()
	it("affine -> jacobian -> affine roundtrip preserves point", function()
		local jac = StarkCurve.jacobianFromAffine(StarkCurve.G)
		local aff = StarkCurve.affineFromJacobian(jac)
		expect(aff ~= nil):toBe(true)
		expect(StarkCurve.affineEq(aff :: any, StarkCurve.G)):toBe(true)
	end)

	it("identity has no affine representation", function()
		local inf = { x = StarkField.one(), y = StarkField.one(), z = StarkField.zero() }
		expect(StarkCurve.affineFromJacobian(inf)):toBe(nil)
	end)

	it("isInfinity detects identity", function()
		local inf = { x = StarkField.one(), y = StarkField.one(), z = StarkField.zero() }
		expect(StarkCurve.isInfinity(inf)):toBe(true)
	end)

	it("isInfinity is false for non-identity", function()
		local jac = StarkCurve.jacobianFromAffine(StarkCurve.G)
		expect(StarkCurve.isInfinity(jac)):toBe(false)
	end)

	it("jacobianFromAffine sets Z=1", function()
		local jac = StarkCurve.jacobianFromAffine(StarkCurve.G)
		expect(StarkField.eq(jac.z, StarkField.one())):toBe(true)
	end)
end)

describe("StarkCurve - affineEq and affineNeg", function()
	it("affineEq returns true for same point", function()
		expect(StarkCurve.affineEq(StarkCurve.G, StarkCurve.G)):toBe(true)
	end)

	it("affineEq returns false for different points", function()
		local negG = StarkCurve.affineNeg(StarkCurve.G)
		expect(StarkCurve.affineEq(StarkCurve.G, negG)):toBe(false)
	end)

	it("affineNeg preserves x coordinate", function()
		local negG = StarkCurve.affineNeg(StarkCurve.G)
		expect(StarkField.eq(negG.x, StarkCurve.G.x)):toBe(true)
	end)

	it("affineNeg negates y coordinate", function()
		local negG = StarkCurve.affineNeg(StarkCurve.G)
		expect(StarkField.isZero(StarkField.add(negG.y, StarkCurve.G.y))):toBe(true)
	end)

	it("double negation returns original", function()
		local negNegG = StarkCurve.affineNeg(StarkCurve.affineNeg(StarkCurve.G))
		expect(StarkCurve.affineEq(negNegG, StarkCurve.G)):toBe(true)
	end)
end)

describe("StarkCurve - Point Doubling", function()
	it("2G is on the curve", function()
		local jac = StarkCurve.jacobianFromAffine(StarkCurve.G)
		local doubled = StarkCurve.jacobianDouble(jac)
		local aff = StarkCurve.affineFromJacobian(doubled)
		expect(aff ~= nil):toBe(true)
		expect(StarkCurve.isOnCurve(aff :: any)):toBe(true)
	end)

	it("2G differs from G", function()
		local jac = StarkCurve.jacobianFromAffine(StarkCurve.G)
		local doubled = StarkCurve.jacobianDouble(jac)
		local twoG = StarkCurve.affineFromJacobian(doubled)
		expect(twoG ~= nil):toBe(true)
		expect(StarkCurve.affineEq(twoG :: any, StarkCurve.G)):toBe(false)
	end)

	it("doubling identity returns identity", function()
		local inf = { x = StarkField.one(), y = StarkField.one(), z = StarkField.zero() }
		local result = StarkCurve.jacobianDouble(inf)
		expect(StarkCurve.isInfinity(result)):toBe(true)
	end)

	it("4G = double(2G)", function()
		local jG = StarkCurve.jacobianFromAffine(StarkCurve.G)
		local j2G = StarkCurve.jacobianDouble(jG)
		local j4G = StarkCurve.jacobianDouble(j2G)
		local fourG = StarkCurve.affineFromJacobian(j4G)
		expect(fourG ~= nil):toBe(true)
		expect(StarkCurve.isOnCurve(fourG :: any)):toBe(true)
	end)
end)

describe("StarkCurve - Point Addition", function()
	it("G + identity = G", function()
		local jG = StarkCurve.jacobianFromAffine(StarkCurve.G)
		local inf = { x = StarkField.one(), y = StarkField.one(), z = StarkField.zero() }
		local result = StarkCurve.jacobianAdd(jG, inf)
		local aff = StarkCurve.affineFromJacobian(result)
		expect(aff ~= nil):toBe(true)
		expect(StarkCurve.affineEq(aff :: any, StarkCurve.G)):toBe(true)
	end)

	it("identity + G = G", function()
		local jG = StarkCurve.jacobianFromAffine(StarkCurve.G)
		local inf = { x = StarkField.one(), y = StarkField.one(), z = StarkField.zero() }
		local result = StarkCurve.jacobianAdd(inf, jG)
		local aff = StarkCurve.affineFromJacobian(result)
		expect(aff ~= nil):toBe(true)
		expect(StarkCurve.affineEq(aff :: any, StarkCurve.G)):toBe(true)
	end)

	it("G + (-G) = identity", function()
		local negG = StarkCurve.affineNeg(StarkCurve.G)
		local jG = StarkCurve.jacobianFromAffine(StarkCurve.G)
		local jNegG = StarkCurve.jacobianFromAffine(negG)
		local result = StarkCurve.jacobianAdd(jG, jNegG)
		expect(StarkCurve.isInfinity(result)):toBe(true)
	end)

	it("G + G = 2G (matches doubling)", function()
		local jG = StarkCurve.jacobianFromAffine(StarkCurve.G)
		local addResult = StarkCurve.jacobianAdd(jG, jG)
		local doubleResult = StarkCurve.jacobianDouble(jG)
		local addAff = StarkCurve.affineFromJacobian(addResult)
		local doubleAff = StarkCurve.affineFromJacobian(doubleResult)
		expect(addAff ~= nil):toBe(true)
		expect(doubleAff ~= nil):toBe(true)
		expect(StarkCurve.affineEq(addAff :: any, doubleAff :: any)):toBe(true)
	end)

	it("3G = G + 2G", function()
		local jG = StarkCurve.jacobianFromAffine(StarkCurve.G)
		local j2G = StarkCurve.jacobianDouble(jG)
		local j3G = StarkCurve.jacobianAdd(jG, j2G)
		local threeG = StarkCurve.affineFromJacobian(j3G)
		expect(threeG ~= nil):toBe(true)
		expect(StarkCurve.isOnCurve(threeG :: any)):toBe(true)
	end)

	it("3G = 2G + G (commutative)", function()
		local jG = StarkCurve.jacobianFromAffine(StarkCurve.G)
		local j2G = StarkCurve.jacobianDouble(jG)
		local r1 = StarkCurve.affineFromJacobian(StarkCurve.jacobianAdd(jG, j2G))
		local r2 = StarkCurve.affineFromJacobian(StarkCurve.jacobianAdd(j2G, jG))
		expect(r1 ~= nil):toBe(true)
		expect(r2 ~= nil):toBe(true)
		expect(StarkCurve.affineEq(r1 :: any, r2 :: any)):toBe(true)
	end)

	it("(G + 2G) + 3G = G + (2G + 3G) (associative)", function()
		local jG = StarkCurve.jacobianFromAffine(StarkCurve.G)
		local j2G = StarkCurve.jacobianDouble(jG)
		local j3G = StarkCurve.jacobianAdd(jG, j2G)
		-- (G + 2G) + 3G = 3G + 3G = 6G
		local lhs = StarkCurve.affineFromJacobian(StarkCurve.jacobianAdd(j3G, j3G))
		-- G + (2G + 3G) = G + 5G = 6G
		local j5G = StarkCurve.jacobianAdd(j2G, j3G)
		local rhs = StarkCurve.affineFromJacobian(StarkCurve.jacobianAdd(jG, j5G))
		expect(lhs ~= nil):toBe(true)
		expect(rhs ~= nil):toBe(true)
		expect(StarkCurve.affineEq(lhs :: any, rhs :: any)):toBe(true)
	end)
end)

describe("StarkCurve - Scalar Multiplication", function()
	it("1 * G = G", function()
		local result = StarkCurve.scalarMul(StarkCurve.G, BigInt.one())
		expect(result ~= nil):toBe(true)
		expect(StarkCurve.affineEq(result :: any, StarkCurve.G)):toBe(true)
	end)

	it("2 * G matches doubling", function()
		local scalarResult = StarkCurve.scalarMul(StarkCurve.G, BigInt.fromNumber(2))
		local jG = StarkCurve.jacobianFromAffine(StarkCurve.G)
		local doubleResult = StarkCurve.affineFromJacobian(StarkCurve.jacobianDouble(jG))
		expect(scalarResult ~= nil):toBe(true)
		expect(doubleResult ~= nil):toBe(true)
		expect(StarkCurve.affineEq(scalarResult :: any, doubleResult :: any)):toBe(true)
	end)

	it("3 * G matches G + 2G", function()
		local scalarResult = StarkCurve.scalarMul(StarkCurve.G, BigInt.fromNumber(3))
		local jG = StarkCurve.jacobianFromAffine(StarkCurve.G)
		local j2G = StarkCurve.jacobianDouble(jG)
		local addResult = StarkCurve.affineFromJacobian(StarkCurve.jacobianAdd(jG, j2G))
		expect(scalarResult ~= nil):toBe(true)
		expect(addResult ~= nil):toBe(true)
		expect(StarkCurve.affineEq(scalarResult :: any, addResult :: any)):toBe(true)
	end)

	it("4 * G = 2 * (2G)", function()
		local fourG = StarkCurve.scalarMul(StarkCurve.G, BigInt.fromNumber(4))
		local jG = StarkCurve.jacobianFromAffine(StarkCurve.G)
		local j4G = StarkCurve.jacobianDouble(StarkCurve.jacobianDouble(jG))
		local expected = StarkCurve.affineFromJacobian(j4G)
		expect(fourG ~= nil):toBe(true)
		expect(expected ~= nil):toBe(true)
		expect(StarkCurve.affineEq(fourG :: any, expected :: any)):toBe(true)
	end)

	it("5 * G is on the curve", function()
		local result = StarkCurve.scalarMul(StarkCurve.G, BigInt.fromNumber(5))
		expect(result ~= nil):toBe(true)
		expect(StarkCurve.isOnCurve(result :: any)):toBe(true)
	end)

	it("0 * G returns nil (identity)", function()
		local result = StarkCurve.scalarMul(StarkCurve.G, BigInt.zero())
		expect(result == nil):toBe(true)
	end)

	it("(a+b) * G = a*G + b*G (distributivity)", function()
		local a = BigInt.fromNumber(7)
		local b = BigInt.fromNumber(11)
		local ab = BigInt.fromNumber(18)
		local abG = StarkCurve.scalarMul(StarkCurve.G, ab)
		local aG = StarkCurve.scalarMul(StarkCurve.G, a)
		local bG = StarkCurve.scalarMul(StarkCurve.G, b)
		local jaG = StarkCurve.jacobianFromAffine(aG :: any)
		local jbG = StarkCurve.jacobianFromAffine(bG :: any)
		local sum = StarkCurve.affineFromJacobian(StarkCurve.jacobianAdd(jaG, jbG))
		expect(abG ~= nil):toBe(true)
		expect(sum ~= nil):toBe(true)
		expect(StarkCurve.affineEq(abG :: any, sum :: any)):toBe(true)
	end)

	it("scalar mul with larger value (1000 * G) is on curve", function()
		local result = StarkCurve.scalarMul(StarkCurve.G, BigInt.fromNumber(1000))
		expect(result ~= nil):toBe(true)
		expect(StarkCurve.isOnCurve(result :: any)):toBe(true)
	end)

	it("scalar mul is consistent across different decompositions", function()
		-- 6*G via scalarMul(G, 6)
		local sixG_direct = StarkCurve.scalarMul(StarkCurve.G, BigInt.fromNumber(6))
		-- 6*G via 2*(3*G)
		local threeG = StarkCurve.scalarMul(StarkCurve.G, BigInt.fromNumber(3))
		local sixG_via3 = StarkCurve.scalarMul(threeG :: any, BigInt.fromNumber(2))
		expect(sixG_direct ~= nil):toBe(true)
		expect(sixG_via3 ~= nil):toBe(true)
		expect(StarkCurve.affineEq(sixG_direct :: any, sixG_via3 :: any)):toBe(true)
	end)

	it("scalar mul with 128-bit key is on curve", function()
		local k = BigInt.fromHex("0xdeadbeef12345678cafebabe87654321")
		local result = StarkCurve.scalarMul(StarkCurve.G, k)
		expect(result ~= nil):toBe(true)
		expect(StarkCurve.isOnCurve(result :: any)):toBe(true)
	end)
end)

describe("StarkCurve - getPublicKey", function()
	it("getPublicKey(1) returns generator G", function()
		local pubKey = StarkCurve.getPublicKey(BigInt.one())
		expect(StarkCurve.affineEq(pubKey, StarkCurve.G)):toBe(true)
	end)

	it("getPublicKey(1).x matches starknet.js getStarkKey('0x1')", function()
		local pubKey = StarkCurve.getPublicKey(BigInt.one())
		expect(StarkField.toHex(pubKey.x)):toBe(GX_HEX)
	end)

	it("public key is always on curve", function()
		local pubKey = StarkCurve.getPublicKey(BigInt.fromNumber(42))
		expect(StarkCurve.isOnCurve(pubKey)):toBe(true)
	end)

	it("different private keys produce different public keys", function()
		local pub1 = StarkCurve.getPublicKey(BigInt.fromNumber(1))
		local pub2 = StarkCurve.getPublicKey(BigInt.fromNumber(2))
		expect(StarkCurve.affineEq(pub1, pub2)):toBe(false)
	end)

	it("getPublicKey(0) throws", function()
		expect(function()
			StarkCurve.getPublicKey(BigInt.zero())
		end):toThrow()
	end)

	it("getPublicKey with key >= N throws", function()
		expect(function()
			StarkCurve.getPublicKey(StarkCurve.N)
		end):toThrow()
	end)

	it("getPublicKey with hex private key", function()
		local pubKey = StarkCurve.getPublicKey(BigInt.fromHex("0xdeadbeef"))
		expect(StarkCurve.isOnCurve(pubKey)):toBe(true)
	end)

	it("getPublicKey(2) matches 2*G", function()
		local pub2 = StarkCurve.getPublicKey(BigInt.fromNumber(2))
		local jG = StarkCurve.jacobianFromAffine(StarkCurve.G)
		local twoG = StarkCurve.affineFromJacobian(StarkCurve.jacobianDouble(jG))
		expect(twoG ~= nil):toBe(true)
		expect(StarkCurve.affineEq(pub2, twoG :: any)):toBe(true)
	end)
end)

describe("StarkCurve - Edge Cases", function()
	it("doubling a point with Y=0 returns identity", function()
		local p = { x = StarkField.one(), y = StarkField.zero(), z = StarkField.one() }
		local result = StarkCurve.jacobianDouble(p)
		expect(StarkCurve.isInfinity(result)):toBe(true)
	end)

	it("adding a point to its negation gives identity (5G + (-5G))", function()
		local fiveG = StarkCurve.scalarMul(StarkCurve.G, BigInt.fromNumber(5))
		expect(fiveG ~= nil):toBe(true)
		local negFiveG = StarkCurve.affineNeg(fiveG :: any)
		local jP = StarkCurve.jacobianFromAffine(fiveG :: any)
		local jNegP = StarkCurve.jacobianFromAffine(negFiveG)
		local result = StarkCurve.jacobianAdd(jP, jNegP)
		expect(StarkCurve.isInfinity(result)):toBe(true)
	end)

	it("multiple scalar muls produce consistent results", function()
		-- 10*G via scalarMul(G, 10)
		local tenG = StarkCurve.scalarMul(StarkCurve.G, BigInt.fromNumber(10))
		-- 10*G via scalarMul(5G, 2)
		local fiveG = StarkCurve.scalarMul(StarkCurve.G, BigInt.fromNumber(5))
		local tenG_via5 = StarkCurve.scalarMul(fiveG :: any, BigInt.fromNumber(2))
		-- 10*G via scalarMul(2G, 5)
		local twoG = StarkCurve.scalarMul(StarkCurve.G, BigInt.fromNumber(2))
		local tenG_via2 = StarkCurve.scalarMul(twoG :: any, BigInt.fromNumber(5))
		expect(tenG ~= nil):toBe(true)
		expect(tenG_via5 ~= nil):toBe(true)
		expect(tenG_via2 ~= nil):toBe(true)
		expect(StarkCurve.affineEq(tenG :: any, tenG_via5 :: any)):toBe(true)
		expect(StarkCurve.affineEq(tenG :: any, tenG_via2 :: any)):toBe(true)
	end)

	it("(N-1)*G is the negation of G", function()
		-- (N-1)*G = N*G - G = O - G = -G
		local nMinus1 = BigInt.sub(StarkCurve.N, BigInt.one())
		local result = StarkCurve.scalarMul(StarkCurve.G, nMinus1)
		expect(result ~= nil):toBe(true)
		local negG = StarkCurve.affineNeg(StarkCurve.G)
		expect(StarkCurve.affineEq(result :: any, negG)):toBe(true)
	end)
end)
